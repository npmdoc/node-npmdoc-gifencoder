<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/eugeneware/gifencoder"

    >gifencoder (v1.0.6)</a>
</h1>
<h4>Streaming server-side animated (and non-animated) gif generation for node.js</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.gifencoder">module gifencoder</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gifencoder.gifencoder">
            function <span class="apidocSignatureSpan"></span>gifencoder
            <span class="apidocSignatureSpan">(width, height)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gifencoder.GIFEncoder">
            function <span class="apidocSignatureSpan">gifencoder.</span>GIFEncoder
            <span class="apidocSignatureSpan">(width, height)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gifencoder.Gruntfile">
            function <span class="apidocSignatureSpan">gifencoder.</span>Gruntfile
            <span class="apidocSignatureSpan">(grunt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gifencoder.LZWEncoder">
            function <span class="apidocSignatureSpan">gifencoder.</span>LZWEncoder
            <span class="apidocSignatureSpan">(width, height, pixels, colorDepth)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gifencoder.NeuQuant">
            function <span class="apidocSignatureSpan">gifencoder.</span>NeuQuant
            <span class="apidocSignatureSpan">(pixels, samplefac)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gifencoder.TypedNeuQuant">
            function <span class="apidocSignatureSpan">gifencoder.</span>TypedNeuQuant
            <span class="apidocSignatureSpan">(pixels, samplefac)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gifencoder.toString">
            function <span class="apidocSignatureSpan">gifencoder.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gifencoder.Gruntfile">module gifencoder.Gruntfile</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gifencoder.Gruntfile.Gruntfile">
            function <span class="apidocSignatureSpan">gifencoder.</span>Gruntfile
            <span class="apidocSignatureSpan">(grunt)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gifencoder.LZWEncoder">module gifencoder.LZWEncoder</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gifencoder.LZWEncoder.LZWEncoder">
            function <span class="apidocSignatureSpan">gifencoder.</span>LZWEncoder
            <span class="apidocSignatureSpan">(width, height, pixels, colorDepth)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gifencoder.NeuQuant">module gifencoder.NeuQuant</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gifencoder.NeuQuant.NeuQuant">
            function <span class="apidocSignatureSpan">gifencoder.</span>NeuQuant
            <span class="apidocSignatureSpan">(pixels, samplefac)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gifencoder.TypedNeuQuant">module gifencoder.TypedNeuQuant</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gifencoder.TypedNeuQuant.TypedNeuQuant">
            function <span class="apidocSignatureSpan">gifencoder.</span>TypedNeuQuant
            <span class="apidocSignatureSpan">(pixels, samplefac)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gifencoder.toString">module gifencoder.toString</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gifencoder.toString.toString">
            function <span class="apidocSignatureSpan">gifencoder.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gifencoder" id="apidoc.module.gifencoder">module gifencoder</a></h1>


    <h2>
        <a href="#apidoc.element.gifencoder.gifencoder" id="apidoc.element.gifencoder.gifencoder">
        function <span class="apidocSignatureSpan"></span>gifencoder
        <span class="apidocSignatureSpan">(width, height)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function GIFEncoder(width, height) {
  // image size
  this.width = ~~width;
  this.height = ~~height;

  // transparent color if given
  this.transparent = null;

  // transparent index in color table
  this.transIndex = 0;

  // -1 = no repeat, 0 = forever. anything else is repeat count
  this.repeat = -1;

  // frame delay (hundredths)
  this.delay = 0;

  this.image = null; // current frame
  this.pixels = null; // BGR byte array from frame
  this.indexedPixels = null; // converted frame indexed to palette
  this.colorDepth = null; // number of bit planes
  this.colorTab = null; // RGB palette
  this.usedEntry = new Array(); // active palette entries
  this.palSize = 7; // color table size (bits-1)
  this.dispose = -1; // disposal code (-1 = use default)
  this.firstFrame = true;
  this.sample = 10; // default sample interval for quantizer

  this.started = false; // started encoding

  this.readStreams = [];

  this.out = new ByteArray();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gifencoder.GIFEncoder" id="apidoc.element.gifencoder.GIFEncoder">
        function <span class="apidocSignatureSpan">gifencoder.</span>GIFEncoder
        <span class="apidocSignatureSpan">(width, height)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function GIFEncoder(width, height) {
  // image size
  this.width = ~~width;
  this.height = ~~height;

  // transparent color if given
  this.transparent = null;

  // transparent index in color table
  this.transIndex = 0;

  // -1 = no repeat, 0 = forever. anything else is repeat count
  this.repeat = -1;

  // frame delay (hundredths)
  this.delay = 0;

  this.image = null; // current frame
  this.pixels = null; // BGR byte array from frame
  this.indexedPixels = null; // converted frame indexed to palette
  this.colorDepth = null; // number of bit planes
  this.colorTab = null; // RGB palette
  this.usedEntry = new Array(); // active palette entries
  this.palSize = 7; // color table size (bits-1)
  this.dispose = -1; // disposal code (-1 = use default)
  this.firstFrame = true;
  this.sample = 10; // default sample interval for quantizer

  this.started = false; // started encoding

  this.readStreams = [];

  this.out = new ByteArray();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gifencoder.Gruntfile" id="apidoc.element.gifencoder.Gruntfile">
        function <span class="apidocSignatureSpan">gifencoder.</span>Gruntfile
        <span class="apidocSignatureSpan">(grunt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Gruntfile = function (grunt) {
  grunt.initConfig({
    pkg: grunt.file.readJSON(&#x27;package.json&#x27;),
    complexity: {
      generic: {
        src: [&#x27;app/**/*.js&#x27;],
        options: {
          errorsOnly: false,
          cyclometric: 6,       // default is 3
          halstead: 16,         // default is 8
          maintainability: 100  // default is 100
        }
      }
    },
    jshint: {
      all: [
        &#x27;Gruntfile.js&#x27;,
        &#x27;app/**/*.js&#x27;,
        &#x27;test/**/*.js&#x27;
      ],
      options: {
        jshintrc: &#x27;.jshintrc&#x27;
      }
    },
    mochacli: {
      all: [&#x27;test/**/*.js&#x27;],
      options: {
        reporter: &#x27;spec&#x27;,
        ui: &#x27;tdd&#x27;
      }
    },
    watch: {
      js: {
        files: [&#x27;**/*.js&#x27;],
        tasks: [&#x27;default&#x27;],
        options: {
          nospawn: true
        }
      }
    }
  });

  grunt.loadNpmTasks(&#x27;grunt-complexity&#x27;);
  grunt.loadNpmTasks(&#x27;grunt-contrib-jshint&#x27;);
  grunt.loadNpmTasks(&#x27;grunt-contrib-watch&#x27;);
  grunt.loadNpmTasks(&#x27;grunt-mocha-cli&#x27;);

  grunt.registerTask(&#x27;test&#x27;, [&#x27;complexity&#x27;, &#x27;jshint&#x27;, &#x27;mochacli&#x27;, &#x27;watch&#x27;]);
  grunt.registerTask(&#x27;ci&#x27;, [&#x27;complexity&#x27;, &#x27;jshint&#x27;, &#x27;mochacli&#x27;]);
  grunt.registerTask(&#x27;default&#x27;, [&#x27;test&#x27;]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gifencoder.LZWEncoder" id="apidoc.element.gifencoder.LZWEncoder">
        function <span class="apidocSignatureSpan">gifencoder.</span>LZWEncoder
        <span class="apidocSignatureSpan">(width, height, pixels, colorDepth)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LZWEncoder(width, height, pixels, colorDepth) {
  var initCodeSize = Math.max(2, colorDepth);

  var accum = new Uint8Array(256);
  var htab = new Int32Array(HSIZE);
  var codetab = new Int32Array(HSIZE);

  var cur_accum, cur_bits = 0;
  var a_count;
  var free_ent = 0; // first unused entry
  var maxcode;

  // block compression parameters -- after all codes are used up,
  // and compression rate changes, start over.
  var clear_flg = false;

  // Algorithm: use open addressing double hashing (no chaining) on the
  // prefix code / next character combination. We do a variant of Knuth&#x27;s
  // algorithm D (vol. 3, sec. 6.4) along with G. Knott&#x27;s relatively-prime
  // secondary probe. Here, the modular division first probe is gives way
  // to a faster exclusive-or manipulation. Also do block compression with
  // an adaptive reset, whereby the code table is cleared when the compression
  // ratio decreases, but after the table fills. The variable-length output
  // codes are re-sized at this point, and a special CLEAR code is generated
  // for the decompressor. Late addition: construct the table according to
  // file size for noticeable speed improvement on small files. Please direct
  // questions about this implementation to ames!jaw.
  var g_init_bits, ClearCode, EOFCode;

  // Add a character to the end of the current packet, and if it is 254
  // characters, flush the packet to disk.
  function char_out(c, outs) {
    accum[a_count++] = c;
    if (a_count &#x3e;= 254) flush_char(outs);
  }

  // Clear out the hash table
  // table clear for block compress
  function cl_block(outs) {
    cl_hash(HSIZE);
    free_ent = ClearCode + 2;
    clear_flg = true;
    output(ClearCode, outs);
  }

  // Reset code table
  function cl_hash(hsize) {
    for (var i = 0; i &#x3c; hsize; ++i) htab[i] = -1;
  }

  function compress(init_bits, outs) {
    var fcode, c, i, ent, disp, hsize_reg, hshift;

    // Set up the globals: g_init_bits - initial number of bits
    g_init_bits = init_bits;

    // Set up the necessary values
    clear_flg = false;
    n_bits = g_init_bits;
    maxcode = MAXCODE(n_bits);

    ClearCode = 1 &#x3c;&#x3c; (init_bits - 1);
    EOFCode = ClearCode + 1;
    free_ent = ClearCode + 2;

    a_count = 0; // clear packet

    ent = nextPixel();

    hshift = 0;
    for (fcode = HSIZE; fcode &#x3c; 65536; fcode *= 2) ++hshift;
    hshift = 8 - hshift; // set hash code range bound
    hsize_reg = HSIZE;
    cl_hash(hsize_reg); // clear hash table

    output(ClearCode, outs);

    outer_loop: while ((c = nextPixel()) != EOF) {
      fcode = (c &#x3c;&#x3c; BITS) + ent;
      i = (c &#x3c;&#x3c; hshift) ^ ent; // xor hashing
      if (htab[i] === fcode) {
        ent = codetab[i];
        continue;
      } else if (htab[i] &#x3e;= 0) { // non-empty slot
        disp = hsize_reg - i; // secondary hash (after G. Knott)
        if (i === 0) disp = 1;
        do {
          if ((i -= disp) &#x3c; 0) i += hsize_reg;
          if (htab[i] === fcode) {
            ent = codetab[i];
            continue outer_loop;
          }
        } while (htab[i] &#x3e;= 0);
      }
      output(ent, outs);
      ent = c;
      if (free_ent &#x3c; 1 &#x3c;&#x3c; BITS) {
        codetab[i] = free_ent++; // code -&#x3e; hashtable
        htab[i] = fcode;
      } else {
        cl_block(outs);
      }
    }

    // Put out the final code.
    output(ent, outs);
    output(EOFCode, outs);
  }

  function encode(outs) {
    outs.writeByte(initCodeSize); // write &#x22;initial code size&#x22; byte
    remaining = width * height; // reset navigation variables
    curPixel = 0;
    compress(initCodeSize + 1, outs); // compress and write the pixel data
    outs.writeByte(0); // write block terminator
  }

  // Flush the packet to disk, and reset the accumulator
  function flush_char(outs) {
    if (a_count &#x3e; 0) {
      outs.writeByte(a_count);
      outs.writeBytes(accum, 0, a_count);
      a_count = 0;
    }
  }

  function MAXCODE(n_bits) {
    return (1 &#x3c;&#x3c; n_bits) - 1;
  }

  // Return the next pixel from the image
  function nextPixel() {
    if (remaining === 0) return EOF;
    --remaining;
    var pix = pixels[cu ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gifencoder.NeuQuant" id="apidoc.element.gifencoder.NeuQuant">
        function <span class="apidocSignatureSpan">gifencoder.</span>NeuQuant
        <span class="apidocSignatureSpan">(pixels, samplefac)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NeuQuant(pixels, samplefac) {
  var network; // int[netsize][4]
  var netindex; // for network lookup - really 256

  // bias and freq arrays for learning
  var bias;
  var freq;
  var radpower;

<span class="apidocCodeCommentSpan">  /*
    Private Method: init

    sets up arrays
  */
</span>  function init() {
    network = [];
    netindex = [];
    bias = [];
    freq = [];
    radpower = [];

    var i, v;
    for (i = 0; i &#x3c; netsize; i++) {
      v = (i &#x3c;&#x3c; (netbiasshift + 8)) / netsize;
      network[i] = [v, v, v];
      freq[i] = intbias / netsize;
      bias[i] = 0;
    }
  }

  /*
    Private Method: unbiasnet

    unbiases network to give byte values 0..255 and record position i to prepare for sort
  */
  function unbiasnet() {
    for (var i = 0; i &#x3c; netsize; i++) {
      network[i][0] &#x3e;&#x3e;= netbiasshift;
      network[i][1] &#x3e;&#x3e;= netbiasshift;
      network[i][2] &#x3e;&#x3e;= netbiasshift;
      network[i][3] = i; // record color number
    }
  }

  /*
    Private Method: altersingle

    moves neuron *i* towards biased (b,g,r) by factor *alpha*
  */
  function altersingle(alpha, i, b, g, r) {
    network[i][0] -= (alpha * (network[i][0] - b)) / initalpha;
    network[i][1] -= (alpha * (network[i][1] - g)) / initalpha;
    network[i][2] -= (alpha * (network[i][2] - r)) / initalpha;
  }

  /*
    Private Method: alterneigh

    moves neurons in *radius* around index *i* towards biased (b,g,r) by factor *alpha*
  */
  function alterneigh(radius, i, b, g, r) {
    var lo = Math.abs(i - radius);
    var hi = Math.min(i + radius, netsize);

    var j = i + 1;
    var k = i - 1;
    var m = 1;

    var p, a;
    while ((j &#x3c; hi) || (k &#x3e; lo)) {
      a = radpower[m++];

      if (j &#x3c; hi) {
        p = network[j++];
        p[0] -= (a * (p[0] - b)) / alpharadbias;
        p[1] -= (a * (p[1] - g)) / alpharadbias;
        p[2] -= (a * (p[2] - r)) / alpharadbias;
      }

      if (k &#x3e; lo) {
        p = network[k--];
        p[0] -= (a * (p[0] - b)) / alpharadbias;
        p[1] -= (a * (p[1] - g)) / alpharadbias;
        p[2] -= (a * (p[2] - r)) / alpharadbias;
      }
    }
  }

  /*
    Private Method: contest

    searches for biased BGR values
  */
  function contest(b, g, r) {
    /*
      finds closest neuron (min dist) and updates freq
      finds best neuron (min dist-bias) and returns position
      for frequently chosen neurons, freq[i] is high and bias[i] is negative
      bias[i] = gamma * ((1 / netsize) - freq[i])
    */

    var bestd = ~(1 &#x3c;&#x3c; 31);
    var bestbiasd = bestd;
    var bestpos = -1;
    var bestbiaspos = bestpos;

    var i, n, dist, biasdist, betafreq;
    for (i = 0; i &#x3c; netsize; i++) {
      n = network[i];

      dist = Math.abs(n[0] - b) + Math.abs(n[1] - g) + Math.abs(n[2] - r);
      if (dist &#x3c; bestd) {
        bestd = dist;
        bestpos = i;
      }

      biasdist = dist - ((bias[i]) &#x3e;&#x3e; (intbiasshift - netbiasshift));
      if (biasdist &#x3c; bestbiasd) {
        bestbiasd = biasdist;
        bestbiaspos = i;
      }

      betafreq = (freq[i] &#x3e;&#x3e; betashift);
      freq[i] -= betafreq;
      bias[i] += (betafreq &#x3c;&#x3c; gammashift);
    }

    freq[bestpos] += beta;
    bias[bestpos] -= betagamma;

    return bestbiaspos;
  }

  /*
    Private Method: inxbuild

    sorts network and builds netindex[0..255]
  */
  function inxbuild() {
    var i, j, p, q, smallpos, smallval, previouscol = 0, startpos = 0;
    for (i = 0; i &#x3c; netsize; i++) {
      p = network[i];
      smallpos = i;
      smallval = p[1]; // index on g
      // find smallest in i..netsize-1
      for (j = i + 1; j &#x3c; netsize; j++) {
        q = network[j];
        if (q[1] &#x3c; smallval) { // index on g
          smallpos = j;
          smallval = q[1]; // index on g
        }
      }
      q = network[smallpos];
      // swap p (i) and q (smallpos) entries
      if (i != smallpos) {
        j = q[0];   q[0] = p[0];   p[0] = j;
        j = q[1];   q[1] = p[1];   p[1] = j;
        j = q[2];   q[2] = p[2];   p[2] = j;
        j = q[3];   q[3] = p[3];   p[3] = j;
      }
      // smallval entry is now in position i

      if (smallval != previouscol) {
        netindex[previousc ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gifencoder.TypedNeuQuant" id="apidoc.element.gifencoder.TypedNeuQuant">
        function <span class="apidocSignatureSpan">gifencoder.</span>TypedNeuQuant
        <span class="apidocSignatureSpan">(pixels, samplefac)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NeuQuant(pixels, samplefac) {
  var network; // int[netsize][4]
  var netindex; // for network lookup - really 256

  // bias and freq arrays for learning
  var bias;
  var freq;
  var radpower;

<span class="apidocCodeCommentSpan">  /*
    Private Method: init

    sets up arrays
  */
</span>  function init() {
    network = [];
    netindex = new Int32Array(256);
    bias = new Int32Array(netsize);
    freq = new Int32Array(netsize);
    radpower = new Int32Array(netsize &#x3e;&#x3e; 3);

    var i, v;
    for (i = 0; i &#x3c; netsize; i++) {
      v = (i &#x3c;&#x3c; (netbiasshift + 8)) / netsize;
      network[i] = new Float64Array([v, v, v, 0]);
      //network[i] = [v, v, v, 0]
      freq[i] = intbias / netsize;
      bias[i] = 0;
    }
  }

  /*
    Private Method: unbiasnet

    unbiases network to give byte values 0..255 and record position i to prepare for sort
  */
  function unbiasnet() {
    for (var i = 0; i &#x3c; netsize; i++) {
      network[i][0] &#x3e;&#x3e;= netbiasshift;
      network[i][1] &#x3e;&#x3e;= netbiasshift;
      network[i][2] &#x3e;&#x3e;= netbiasshift;
      network[i][3] = i; // record color number
    }
  }

  /*
    Private Method: altersingle

    moves neuron *i* towards biased (b,g,r) by factor *alpha*
  */
  function altersingle(alpha, i, b, g, r) {
    network[i][0] -= (alpha * (network[i][0] - b)) / initalpha;
    network[i][1] -= (alpha * (network[i][1] - g)) / initalpha;
    network[i][2] -= (alpha * (network[i][2] - r)) / initalpha;
  }

  /*
    Private Method: alterneigh

    moves neurons in *radius* around index *i* towards biased (b,g,r) by factor *alpha*
  */
  function alterneigh(radius, i, b, g, r) {
    var lo = Math.abs(i - radius);
    var hi = Math.min(i + radius, netsize);

    var j = i + 1;
    var k = i - 1;
    var m = 1;

    var p, a;
    while ((j &#x3c; hi) || (k &#x3e; lo)) {
      a = radpower[m++];

      if (j &#x3c; hi) {
        p = network[j++];
        p[0] -= (a * (p[0] - b)) / alpharadbias;
        p[1] -= (a * (p[1] - g)) / alpharadbias;
        p[2] -= (a * (p[2] - r)) / alpharadbias;
      }

      if (k &#x3e; lo) {
        p = network[k--];
        p[0] -= (a * (p[0] - b)) / alpharadbias;
        p[1] -= (a * (p[1] - g)) / alpharadbias;
        p[2] -= (a * (p[2] - r)) / alpharadbias;
      }
    }
  }

  /*
    Private Method: contest

    searches for biased BGR values
  */
  function contest(b, g, r) {
    /*
      finds closest neuron (min dist) and updates freq
      finds best neuron (min dist-bias) and returns position
      for frequently chosen neurons, freq[i] is high and bias[i] is negative
      bias[i] = gamma * ((1 / netsize) - freq[i])
    */

    var bestd = ~(1 &#x3c;&#x3c; 31);
    var bestbiasd = bestd;
    var bestpos = -1;
    var bestbiaspos = bestpos;

    var i, n, dist, biasdist, betafreq;
    for (i = 0; i &#x3c; netsize; i++) {
      n = network[i];

      dist = Math.abs(n[0] - b) + Math.abs(n[1] - g) + Math.abs(n[2] - r);
      if (dist &#x3c; bestd) {
        bestd = dist;
        bestpos = i;
      }

      biasdist = dist - ((bias[i]) &#x3e;&#x3e; (intbiasshift - netbiasshift));
      if (biasdist &#x3c; bestbiasd) {
        bestbiasd = biasdist;
        bestbiaspos = i;
      }

      betafreq = (freq[i] &#x3e;&#x3e; betashift);
      freq[i] -= betafreq;
      bias[i] += (betafreq &#x3c;&#x3c; gammashift);
    }

    freq[bestpos] += beta;
    bias[bestpos] -= betagamma;

    return bestbiaspos;
  }

  /*
    Private Method: inxbuild

    sorts network and builds netindex[0..255]
  */
  function inxbuild() {
    var i, j, p, q, smallpos, smallval, previouscol = 0, startpos = 0;
    for (i = 0; i &#x3c; netsize; i++) {
      p = network[i];
      smallpos = i;
      smallval = p[1]; // index on g
      // find smallest in i..netsize-1
      for (j = i + 1; j &#x3c; netsize; j++) {
        q = network[j];
        if (q[1] &#x3c; smallval) { // index on g
          smallpos = j;
          smallval = q[1]; // index on g
        }
      }
      q = network[smallpos];
      // swap p (i) and q (smallpos) entries
      if (i != smallpos) {
        j = q[0];   q[0] = p[0];   p[0] = j;
        j = q[1];   q[1] = p[1];   p[1] = j;
        j = q[2];   q[2] = p[2];   p[2] = j;
        j = q[3];   q[ ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gifencoder.toString" id="apidoc.element.gifencoder.toString">
        function <span class="apidocSignatureSpan">gifencoder.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
    return text;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gifencoder.Gruntfile" id="apidoc.module.gifencoder.Gruntfile">module gifencoder.Gruntfile</a></h1>


    <h2>
        <a href="#apidoc.element.gifencoder.Gruntfile.Gruntfile" id="apidoc.element.gifencoder.Gruntfile.Gruntfile">
        function <span class="apidocSignatureSpan">gifencoder.</span>Gruntfile
        <span class="apidocSignatureSpan">(grunt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Gruntfile = function (grunt) {
  grunt.initConfig({
    pkg: grunt.file.readJSON(&#x27;package.json&#x27;),
    complexity: {
      generic: {
        src: [&#x27;app/**/*.js&#x27;],
        options: {
          errorsOnly: false,
          cyclometric: 6,       // default is 3
          halstead: 16,         // default is 8
          maintainability: 100  // default is 100
        }
      }
    },
    jshint: {
      all: [
        &#x27;Gruntfile.js&#x27;,
        &#x27;app/**/*.js&#x27;,
        &#x27;test/**/*.js&#x27;
      ],
      options: {
        jshintrc: &#x27;.jshintrc&#x27;
      }
    },
    mochacli: {
      all: [&#x27;test/**/*.js&#x27;],
      options: {
        reporter: &#x27;spec&#x27;,
        ui: &#x27;tdd&#x27;
      }
    },
    watch: {
      js: {
        files: [&#x27;**/*.js&#x27;],
        tasks: [&#x27;default&#x27;],
        options: {
          nospawn: true
        }
      }
    }
  });

  grunt.loadNpmTasks(&#x27;grunt-complexity&#x27;);
  grunt.loadNpmTasks(&#x27;grunt-contrib-jshint&#x27;);
  grunt.loadNpmTasks(&#x27;grunt-contrib-watch&#x27;);
  grunt.loadNpmTasks(&#x27;grunt-mocha-cli&#x27;);

  grunt.registerTask(&#x27;test&#x27;, [&#x27;complexity&#x27;, &#x27;jshint&#x27;, &#x27;mochacli&#x27;, &#x27;watch&#x27;]);
  grunt.registerTask(&#x27;ci&#x27;, [&#x27;complexity&#x27;, &#x27;jshint&#x27;, &#x27;mochacli&#x27;]);
  grunt.registerTask(&#x27;default&#x27;, [&#x27;test&#x27;]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gifencoder.LZWEncoder" id="apidoc.module.gifencoder.LZWEncoder">module gifencoder.LZWEncoder</a></h1>


    <h2>
        <a href="#apidoc.element.gifencoder.LZWEncoder.LZWEncoder" id="apidoc.element.gifencoder.LZWEncoder.LZWEncoder">
        function <span class="apidocSignatureSpan">gifencoder.</span>LZWEncoder
        <span class="apidocSignatureSpan">(width, height, pixels, colorDepth)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LZWEncoder(width, height, pixels, colorDepth) {
  var initCodeSize = Math.max(2, colorDepth);

  var accum = new Uint8Array(256);
  var htab = new Int32Array(HSIZE);
  var codetab = new Int32Array(HSIZE);

  var cur_accum, cur_bits = 0;
  var a_count;
  var free_ent = 0; // first unused entry
  var maxcode;

  // block compression parameters -- after all codes are used up,
  // and compression rate changes, start over.
  var clear_flg = false;

  // Algorithm: use open addressing double hashing (no chaining) on the
  // prefix code / next character combination. We do a variant of Knuth&#x27;s
  // algorithm D (vol. 3, sec. 6.4) along with G. Knott&#x27;s relatively-prime
  // secondary probe. Here, the modular division first probe is gives way
  // to a faster exclusive-or manipulation. Also do block compression with
  // an adaptive reset, whereby the code table is cleared when the compression
  // ratio decreases, but after the table fills. The variable-length output
  // codes are re-sized at this point, and a special CLEAR code is generated
  // for the decompressor. Late addition: construct the table according to
  // file size for noticeable speed improvement on small files. Please direct
  // questions about this implementation to ames!jaw.
  var g_init_bits, ClearCode, EOFCode;

  // Add a character to the end of the current packet, and if it is 254
  // characters, flush the packet to disk.
  function char_out(c, outs) {
    accum[a_count++] = c;
    if (a_count &#x3e;= 254) flush_char(outs);
  }

  // Clear out the hash table
  // table clear for block compress
  function cl_block(outs) {
    cl_hash(HSIZE);
    free_ent = ClearCode + 2;
    clear_flg = true;
    output(ClearCode, outs);
  }

  // Reset code table
  function cl_hash(hsize) {
    for (var i = 0; i &#x3c; hsize; ++i) htab[i] = -1;
  }

  function compress(init_bits, outs) {
    var fcode, c, i, ent, disp, hsize_reg, hshift;

    // Set up the globals: g_init_bits - initial number of bits
    g_init_bits = init_bits;

    // Set up the necessary values
    clear_flg = false;
    n_bits = g_init_bits;
    maxcode = MAXCODE(n_bits);

    ClearCode = 1 &#x3c;&#x3c; (init_bits - 1);
    EOFCode = ClearCode + 1;
    free_ent = ClearCode + 2;

    a_count = 0; // clear packet

    ent = nextPixel();

    hshift = 0;
    for (fcode = HSIZE; fcode &#x3c; 65536; fcode *= 2) ++hshift;
    hshift = 8 - hshift; // set hash code range bound
    hsize_reg = HSIZE;
    cl_hash(hsize_reg); // clear hash table

    output(ClearCode, outs);

    outer_loop: while ((c = nextPixel()) != EOF) {
      fcode = (c &#x3c;&#x3c; BITS) + ent;
      i = (c &#x3c;&#x3c; hshift) ^ ent; // xor hashing
      if (htab[i] === fcode) {
        ent = codetab[i];
        continue;
      } else if (htab[i] &#x3e;= 0) { // non-empty slot
        disp = hsize_reg - i; // secondary hash (after G. Knott)
        if (i === 0) disp = 1;
        do {
          if ((i -= disp) &#x3c; 0) i += hsize_reg;
          if (htab[i] === fcode) {
            ent = codetab[i];
            continue outer_loop;
          }
        } while (htab[i] &#x3e;= 0);
      }
      output(ent, outs);
      ent = c;
      if (free_ent &#x3c; 1 &#x3c;&#x3c; BITS) {
        codetab[i] = free_ent++; // code -&#x3e; hashtable
        htab[i] = fcode;
      } else {
        cl_block(outs);
      }
    }

    // Put out the final code.
    output(ent, outs);
    output(EOFCode, outs);
  }

  function encode(outs) {
    outs.writeByte(initCodeSize); // write &#x22;initial code size&#x22; byte
    remaining = width * height; // reset navigation variables
    curPixel = 0;
    compress(initCodeSize + 1, outs); // compress and write the pixel data
    outs.writeByte(0); // write block terminator
  }

  // Flush the packet to disk, and reset the accumulator
  function flush_char(outs) {
    if (a_count &#x3e; 0) {
      outs.writeByte(a_count);
      outs.writeBytes(accum, 0, a_count);
      a_count = 0;
    }
  }

  function MAXCODE(n_bits) {
    return (1 &#x3c;&#x3c; n_bits) - 1;
  }

  // Return the next pixel from the image
  function nextPixel() {
    if (remaining === 0) return EOF;
    --remaining;
    var pix = pixels[cu ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gifencoder.NeuQuant" id="apidoc.module.gifencoder.NeuQuant">module gifencoder.NeuQuant</a></h1>


    <h2>
        <a href="#apidoc.element.gifencoder.NeuQuant.NeuQuant" id="apidoc.element.gifencoder.NeuQuant.NeuQuant">
        function <span class="apidocSignatureSpan">gifencoder.</span>NeuQuant
        <span class="apidocSignatureSpan">(pixels, samplefac)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NeuQuant(pixels, samplefac) {
  var network; // int[netsize][4]
  var netindex; // for network lookup - really 256

  // bias and freq arrays for learning
  var bias;
  var freq;
  var radpower;

<span class="apidocCodeCommentSpan">  /*
    Private Method: init

    sets up arrays
  */
</span>  function init() {
    network = [];
    netindex = [];
    bias = [];
    freq = [];
    radpower = [];

    var i, v;
    for (i = 0; i &#x3c; netsize; i++) {
      v = (i &#x3c;&#x3c; (netbiasshift + 8)) / netsize;
      network[i] = [v, v, v];
      freq[i] = intbias / netsize;
      bias[i] = 0;
    }
  }

  /*
    Private Method: unbiasnet

    unbiases network to give byte values 0..255 and record position i to prepare for sort
  */
  function unbiasnet() {
    for (var i = 0; i &#x3c; netsize; i++) {
      network[i][0] &#x3e;&#x3e;= netbiasshift;
      network[i][1] &#x3e;&#x3e;= netbiasshift;
      network[i][2] &#x3e;&#x3e;= netbiasshift;
      network[i][3] = i; // record color number
    }
  }

  /*
    Private Method: altersingle

    moves neuron *i* towards biased (b,g,r) by factor *alpha*
  */
  function altersingle(alpha, i, b, g, r) {
    network[i][0] -= (alpha * (network[i][0] - b)) / initalpha;
    network[i][1] -= (alpha * (network[i][1] - g)) / initalpha;
    network[i][2] -= (alpha * (network[i][2] - r)) / initalpha;
  }

  /*
    Private Method: alterneigh

    moves neurons in *radius* around index *i* towards biased (b,g,r) by factor *alpha*
  */
  function alterneigh(radius, i, b, g, r) {
    var lo = Math.abs(i - radius);
    var hi = Math.min(i + radius, netsize);

    var j = i + 1;
    var k = i - 1;
    var m = 1;

    var p, a;
    while ((j &#x3c; hi) || (k &#x3e; lo)) {
      a = radpower[m++];

      if (j &#x3c; hi) {
        p = network[j++];
        p[0] -= (a * (p[0] - b)) / alpharadbias;
        p[1] -= (a * (p[1] - g)) / alpharadbias;
        p[2] -= (a * (p[2] - r)) / alpharadbias;
      }

      if (k &#x3e; lo) {
        p = network[k--];
        p[0] -= (a * (p[0] - b)) / alpharadbias;
        p[1] -= (a * (p[1] - g)) / alpharadbias;
        p[2] -= (a * (p[2] - r)) / alpharadbias;
      }
    }
  }

  /*
    Private Method: contest

    searches for biased BGR values
  */
  function contest(b, g, r) {
    /*
      finds closest neuron (min dist) and updates freq
      finds best neuron (min dist-bias) and returns position
      for frequently chosen neurons, freq[i] is high and bias[i] is negative
      bias[i] = gamma * ((1 / netsize) - freq[i])
    */

    var bestd = ~(1 &#x3c;&#x3c; 31);
    var bestbiasd = bestd;
    var bestpos = -1;
    var bestbiaspos = bestpos;

    var i, n, dist, biasdist, betafreq;
    for (i = 0; i &#x3c; netsize; i++) {
      n = network[i];

      dist = Math.abs(n[0] - b) + Math.abs(n[1] - g) + Math.abs(n[2] - r);
      if (dist &#x3c; bestd) {
        bestd = dist;
        bestpos = i;
      }

      biasdist = dist - ((bias[i]) &#x3e;&#x3e; (intbiasshift - netbiasshift));
      if (biasdist &#x3c; bestbiasd) {
        bestbiasd = biasdist;
        bestbiaspos = i;
      }

      betafreq = (freq[i] &#x3e;&#x3e; betashift);
      freq[i] -= betafreq;
      bias[i] += (betafreq &#x3c;&#x3c; gammashift);
    }

    freq[bestpos] += beta;
    bias[bestpos] -= betagamma;

    return bestbiaspos;
  }

  /*
    Private Method: inxbuild

    sorts network and builds netindex[0..255]
  */
  function inxbuild() {
    var i, j, p, q, smallpos, smallval, previouscol = 0, startpos = 0;
    for (i = 0; i &#x3c; netsize; i++) {
      p = network[i];
      smallpos = i;
      smallval = p[1]; // index on g
      // find smallest in i..netsize-1
      for (j = i + 1; j &#x3c; netsize; j++) {
        q = network[j];
        if (q[1] &#x3c; smallval) { // index on g
          smallpos = j;
          smallval = q[1]; // index on g
        }
      }
      q = network[smallpos];
      // swap p (i) and q (smallpos) entries
      if (i != smallpos) {
        j = q[0];   q[0] = p[0];   p[0] = j;
        j = q[1];   q[1] = p[1];   p[1] = j;
        j = q[2];   q[2] = p[2];   p[2] = j;
        j = q[3];   q[3] = p[3];   p[3] = j;
      }
      // smallval entry is now in position i

      if (smallval != previouscol) {
        netindex[previousc ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gifencoder.TypedNeuQuant" id="apidoc.module.gifencoder.TypedNeuQuant">module gifencoder.TypedNeuQuant</a></h1>


    <h2>
        <a href="#apidoc.element.gifencoder.TypedNeuQuant.TypedNeuQuant" id="apidoc.element.gifencoder.TypedNeuQuant.TypedNeuQuant">
        function <span class="apidocSignatureSpan">gifencoder.</span>TypedNeuQuant
        <span class="apidocSignatureSpan">(pixels, samplefac)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NeuQuant(pixels, samplefac) {
  var network; // int[netsize][4]
  var netindex; // for network lookup - really 256

  // bias and freq arrays for learning
  var bias;
  var freq;
  var radpower;

<span class="apidocCodeCommentSpan">  /*
    Private Method: init

    sets up arrays
  */
</span>  function init() {
    network = [];
    netindex = new Int32Array(256);
    bias = new Int32Array(netsize);
    freq = new Int32Array(netsize);
    radpower = new Int32Array(netsize &#x3e;&#x3e; 3);

    var i, v;
    for (i = 0; i &#x3c; netsize; i++) {
      v = (i &#x3c;&#x3c; (netbiasshift + 8)) / netsize;
      network[i] = new Float64Array([v, v, v, 0]);
      //network[i] = [v, v, v, 0]
      freq[i] = intbias / netsize;
      bias[i] = 0;
    }
  }

  /*
    Private Method: unbiasnet

    unbiases network to give byte values 0..255 and record position i to prepare for sort
  */
  function unbiasnet() {
    for (var i = 0; i &#x3c; netsize; i++) {
      network[i][0] &#x3e;&#x3e;= netbiasshift;
      network[i][1] &#x3e;&#x3e;= netbiasshift;
      network[i][2] &#x3e;&#x3e;= netbiasshift;
      network[i][3] = i; // record color number
    }
  }

  /*
    Private Method: altersingle

    moves neuron *i* towards biased (b,g,r) by factor *alpha*
  */
  function altersingle(alpha, i, b, g, r) {
    network[i][0] -= (alpha * (network[i][0] - b)) / initalpha;
    network[i][1] -= (alpha * (network[i][1] - g)) / initalpha;
    network[i][2] -= (alpha * (network[i][2] - r)) / initalpha;
  }

  /*
    Private Method: alterneigh

    moves neurons in *radius* around index *i* towards biased (b,g,r) by factor *alpha*
  */
  function alterneigh(radius, i, b, g, r) {
    var lo = Math.abs(i - radius);
    var hi = Math.min(i + radius, netsize);

    var j = i + 1;
    var k = i - 1;
    var m = 1;

    var p, a;
    while ((j &#x3c; hi) || (k &#x3e; lo)) {
      a = radpower[m++];

      if (j &#x3c; hi) {
        p = network[j++];
        p[0] -= (a * (p[0] - b)) / alpharadbias;
        p[1] -= (a * (p[1] - g)) / alpharadbias;
        p[2] -= (a * (p[2] - r)) / alpharadbias;
      }

      if (k &#x3e; lo) {
        p = network[k--];
        p[0] -= (a * (p[0] - b)) / alpharadbias;
        p[1] -= (a * (p[1] - g)) / alpharadbias;
        p[2] -= (a * (p[2] - r)) / alpharadbias;
      }
    }
  }

  /*
    Private Method: contest

    searches for biased BGR values
  */
  function contest(b, g, r) {
    /*
      finds closest neuron (min dist) and updates freq
      finds best neuron (min dist-bias) and returns position
      for frequently chosen neurons, freq[i] is high and bias[i] is negative
      bias[i] = gamma * ((1 / netsize) - freq[i])
    */

    var bestd = ~(1 &#x3c;&#x3c; 31);
    var bestbiasd = bestd;
    var bestpos = -1;
    var bestbiaspos = bestpos;

    var i, n, dist, biasdist, betafreq;
    for (i = 0; i &#x3c; netsize; i++) {
      n = network[i];

      dist = Math.abs(n[0] - b) + Math.abs(n[1] - g) + Math.abs(n[2] - r);
      if (dist &#x3c; bestd) {
        bestd = dist;
        bestpos = i;
      }

      biasdist = dist - ((bias[i]) &#x3e;&#x3e; (intbiasshift - netbiasshift));
      if (biasdist &#x3c; bestbiasd) {
        bestbiasd = biasdist;
        bestbiaspos = i;
      }

      betafreq = (freq[i] &#x3e;&#x3e; betashift);
      freq[i] -= betafreq;
      bias[i] += (betafreq &#x3c;&#x3c; gammashift);
    }

    freq[bestpos] += beta;
    bias[bestpos] -= betagamma;

    return bestbiaspos;
  }

  /*
    Private Method: inxbuild

    sorts network and builds netindex[0..255]
  */
  function inxbuild() {
    var i, j, p, q, smallpos, smallval, previouscol = 0, startpos = 0;
    for (i = 0; i &#x3c; netsize; i++) {
      p = network[i];
      smallpos = i;
      smallval = p[1]; // index on g
      // find smallest in i..netsize-1
      for (j = i + 1; j &#x3c; netsize; j++) {
        q = network[j];
        if (q[1] &#x3c; smallval) { // index on g
          smallpos = j;
          smallval = q[1]; // index on g
        }
      }
      q = network[smallpos];
      // swap p (i) and q (smallpos) entries
      if (i != smallpos) {
        j = q[0];   q[0] = p[0];   p[0] = j;
        j = q[1];   q[1] = p[1];   p[1] = j;
        j = q[2];   q[2] = p[2];   p[2] = j;
        j = q[3];   q[ ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gifencoder.toString" id="apidoc.module.gifencoder.toString">module gifencoder.toString</a></h1>


    <h2>
        <a href="#apidoc.element.gifencoder.toString.toString" id="apidoc.element.gifencoder.toString.toString">
        function <span class="apidocSignatureSpan">gifencoder.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toString() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
